#!/usr/bin/env python
import argparse

import numpy
import theano
from blocks.serialization import load

import matplotlib
matplotlib.use('Agg')
from matplotlib import cm, pyplot

from mpl_toolkits.axes_grid1 import ImageGrid
from theano import tensor

from ali import streams


def main(main_loop, data_stream, num_pairs, num_steps, save_path):
    ali, = main_loop.model.top_bricks
    x = tensor.tensor4('features')
    y = tensor.matrix('y')
    z = tensor.tensor4('z')
    e = tensor.tensor4('e')
    encode = theano.function([x, y], ali.encode(x, y)) # G_z(x,y)
    decode = theano.function([z, y], ali.decode(z, y)) # G_x(z,y)
    embed = theano.function([y], ali.embed(y)) # e(y)
    decode_embedded = theano.function([z, e], ali.decode_embedded(z, e)) #G_x(z,e(y))

    it = data_stream.get_epoch_iterator()
    all_x, all_y = next(it)
    from_x, from_y = all_x[0:num_pairs*2:2], all_y[0:num_pairs*2:2]
    to_x, to_y = all_x[1:num_pairs*2:2], all_y[1:num_pairs*2:2]
    from_z, to_z = encode(from_x, from_y), encode(to_x, to_y)

    from_e = embed(from_y)
    to_e = embed(to_y)

    from_to_tensor = to_z - from_z
    from_to_embedding_tensor = to_e - from_e
    between_x_list = [from_x]
    for alpha in numpy.linspace(0, 1, num_steps + 1):
        between_z = from_z + alpha * from_to_tensor
        between_e = from_e + alpha * from_to_embedding_tensor
        between_x_list.append(decode_embedded(between_z, between_e))
    between_x_list.append(to_x)

    figure = pyplot.figure()
    grid = ImageGrid(figure, 111, (num_pairs, num_steps + 3), axes_pad=0.1)
    images = numpy.empty(
        (num_pairs * (num_steps + 3),) + between_x_list[0].shape[1:],
        dtype=between_x_list[0].dtype)
    for i, between_x in enumerate(between_x_list):
        images[i::num_steps + 3] = between_x

    for image, axis in zip(images, grid):
        axis.imshow(image.transpose(1, 2, 0).squeeze(),
                    cmap=cm.Greys_r, interpolation='nearest')
        axis.set_yticklabels(['' for _ in range(image.shape[1])])
        axis.set_xticklabels(['' for _ in range(image.shape[2])])
        axis.axis('off')

    if save_path is None:
        pyplot.show(True)
    else:
        pyplot.savefig(save_path, transparent=True, bbox_inches='tight')


if __name__ == "__main__":
    stream_functions = {
        'cifar10': streams.create_cifar10_data_streams,
        'svhn': streams.create_svhn_data_streams,
        'celeba': streams.create_celeba_data_streams,
        'crs': streams.create_crs_data_streams,
        'tiny_imagenet': streams.create_tiny_imagenet_data_streams}
    parser = argparse.ArgumentParser(description="Plot interpolations.")
    parser.add_argument("which_dataset", type=str,
                        choices=tuple(stream_functions.keys()),
                        help="which dataset to compute interpolations on.")
    parser.add_argument("main_loop_path", type=str,
                        help="path to the pickled main loop.")
    parser.add_argument("--num-pairs", type=int, default=10,
                        help="number of pairs of samples to interpolate.")
    parser.add_argument("--num-steps", type=int, default=10,
                        help="number of interpolation steps.")
    parser.add_argument("--save-path", type=str, default=None,
                        help="where to save the interpolations.")
    args = parser.parse_args()

    with open(args.main_loop_path, 'rb') as src:
        main_loop = load(src)
    num_pairs = args.num_pairs
    rng = numpy.random.RandomState()
    _1, _2, data_stream = stream_functions[args.which_dataset](2*num_pairs,
                                                               2*num_pairs,
                                                               sources=('features', 'targets'),
                                                               rng=rng)
    main(main_loop, data_stream, num_pairs, args.num_steps, args.save_path)
